# 智能任务分配场景统一配置 v2.0
# 基于约束明确的世界知识规则执行框架

scenario_name: "intelligent_task_assignment"
domain: "scheduling"
scenario_type: "constraint_based_assignment"  # 约束驱动的分配场景
complexity_level: "medium"

# 实体定义 - 明确的资源调度实体
entities:
  workers:
    description: "工作人员实体（工时管理版）"
    primary_key: "worker_id" 
    attributes:
      worker_id: {type: "string", description: "工作人员ID"}
      worker_name: {type: "string", description: "工作人员姓名"}
      email: {type: "string", description: "工作人员邮箱地址"}
      capabilities: {type: "array", description: "能力标签列表，如['技术支持','数据分析','客户服务']"}
      current_workload_hours: {type: "float", description: "当前工作负载总工时(小时)，最大容量40小时"}
      availability_status: {type: "string", enum: ["available", "busy", "offline"], description: "可用状态"}
      experience_level: {type: "string", enum: ["junior", "intermediate", "senior"], description: "经验等级"}
      last_assignment_time: {type: "string", description: "最近分配时间"}
      team_id: {type: "string", enum: ["frontend_team", "backend_team", "qa_team", "devops_team", "design_team"], description: "所属团队标识，支持团队通信和协作"}

  tasks:
    description: "任务实体（工时管理版）" 
    primary_key: "task_id"
    attributes:
      task_id: {type: "string", description: "任务ID"}
      task_title: {type: "string", description: "任务标题"}
      task_description: {type: "string", description: "任务描述"}
      required_capabilities: {type: "array", description: "所需能力标签"}
      required_hours: {type: "float", description: "预计工时需求(小时)"}
      urgency_level: {type: "integer", description: "紧急程度 1-10 (10最紧急)"}
      complexity_score: {type: "integer", description: "复杂度评分 1-10"}
      deadline: {type: "string", description: "截止时间", nullable: true}
      created_time: {type: "string", description: "创建时间"}
      status: {type: "string", enum: ["pending", "assigned", "in_progress", "completed"], description: "任务状态"}
      dependencies: {type: "array", description: "依赖的任务ID列表(最多一层依赖)", nullable: true}
      assigned_worker_id: {type: "string", description: "分配的工作人员ID (null=未分配, worker_id=已分配)", nullable: true}
      assignment_time: {type: "string", description: "分配时间", nullable: true}
      assignment_rationale: {type: "string", description: "分配理由", nullable: true}

# 基于世界知识的通用分配规则（单一明确规则）
business_rules:
  universal_assignment_rule:
    description: "智能任务分配 - 通用的任务分配原则"
    trigger_conditions:
      task:
        status: "pending"
    expected_outcome:
      - "按照分配原则为待分配任务选择合适的人员并完成分配"
    task_processing_order:
      description: "任务处理顺序规则 - 确保分配结果的唯一性和可预测性"
      dependency_tasks: "有依赖关系的任务必须等待其依赖任务完成后才能处理"
      independent_tasks: "无依赖关系的任务按以下明确优先级顺序处理"
      dependency_activation_logic: "当依赖任务完成后，被激活的依赖任务立即按其优先级插入处理队列，与剩余的无依赖任务在同一队列中按优先级竞争处理顺序"
      priority_rules:
        primary: "按urgency_level降序排列 (10 > 9 > 8 > ... > 1)"
        secondary: "urgency_level相同时，按complexity_score降序排列 (10 > 9 > 8 > ... > 1)"
        uniqueness_requirement: "所有任务的(urgency_level, complexity_score)组合必须唯一，确保在任何时刻队列中都不会出现优先级相同的任务，无论是否有依赖关系"
        mixed_queue_principle: "依赖任务一旦被激活，与无依赖任务在统一优先级队列中处理，严格按(urgency_level, complexity_score)排序"
      processing_sequence_example:
        - "task_A: urgency=10, complexity=8 → 第1个处理"
        - "task_B: urgency=10, complexity=7 → 第2个处理" 
        - "task_C: urgency=9, complexity=10 → 第3个处理"
        - "task_D: urgency=9, complexity=9 → 第4个处理"
        - "dependency_example: task_E依赖task_C，当task_C完成后，task_E立即按其优先级插入队列"
      agent_visibility: "Agent可以完全预测任务处理顺序，无隐藏规则，依赖任务激活后的处理顺序完全由其优先级决定"
    assignment_principles:
      basic_requirements:
        - "人员状态必须为available（可用状态）"
        - "人员技能必须完全覆盖任务要求（worker.capabilities完全包含task.required_capabilities）"
      priority_logic:
        normal_tasks: "当任务为常规任务（urgency_level<8且complexity_score<7）时，在满足基本要求的候选人中，优先选择当前工作负载最低的人员（current_workload_hours最小）"
        urgent_tasks: "当任务紧急（urgency_level≥8）时，在满足基本要求的候选人中优先选择当前工作负载最低的人员（快速响应），负载相同时选择经验较高的"
        complex_tasks: "当任务复杂（complexity_score≥7）时，在满足基本要求的候选人中优先选择经验等级为senior的人员，多个senior中选择负载较低的"
        urgent_and_complex: "当任务既紧急又复杂（urgency≥8且complexity≥7）时，优先选择经验最高的人员，经验相同时选择负载最低的"
        dependent_tasks: "当任务有依赖关系（dependencies非空）且依赖任务状态为pending时，应先为依赖任务分配人员，然后再为当前任务分配人员"
      assignment_execution:
        - "更新任务状态为assigned"
        - "设置assigned_worker_id为选中人员ID"
        - "记录assignment_time为当前时间"
        - "将任务的required_hours加到分配人员的current_workload_hours上"
        - "在assignment_rationale中说明分配理由（如能力匹配、负载考虑、紧急处理、复杂度匹配、依赖优先等）"
    success_criteria:
      - "task.status更新为assigned"
      - "task.assigned_worker_id设置为选中的worker_id"
      - "分配人员的current_workload_hours正确增加了task.required_hours（浮点数精度容差±0.01小时）"
      - "分配逻辑符合对应场景的优先级原则（通过验证分配对象正确性隐式验证）"
    sample_generation:
      query_templates:
        - "请帮忙分配一下待处理的任务"
        - "有一些任务需要安排，请分配给合适的工作人员"  
        - "待分配任务需要处理，请选择合适的人员"
        - "能帮忙给待处理任务分配合适的负责人吗"
        - "有任务需要分配，请安排相关人员处理"
        - "请根据任务要求选择合适的工作人员进行分配"
        - "需要为待处理任务找合适的人来负责，请分配"
        - "有任务需要分配，请安排合适的人员处理"
        - "请帮忙安排一下待处理任务的负责人员"
        - "根据任务特点，请分配给最合适的工作人员"
      agent_responsibility: "根据分配原则，综合考虑人员可用性、技能匹配、工作负载、任务特性等因素进行最优分配"
      expected_outcome_type: "principle_based_assignment"
      data_constraints:
        ensure_available_workers: "至少1个availability_status为available的worker"
        ensure_capability_match: "至少1个worker的capabilities与task.required_capabilities有交集"
        ensure_workload_variety: "available匹配worker的current_workload_hours有差异"

# ============================================
# 预期答案合成算法设计
# ============================================
# 本section描述样本生成器如何计算预期分配结果（ground truth）

expected_answer_synthesis_algorithm:
  algorithm_name: "QueueBasedAssignmentAlgorithm"
  algorithm_type: "基于优先队列的确定性分配算法"
  algorithm_file: "legacy_files/assignment_algorithm.py"

  core_design_principles:
    determinism: "算法必须产生唯一确定的分配结果，确保样本的ground truth准确性"
    transparency: "分配逻辑完全透明，Agent可预测任务处理顺序和分配结果"
    consistency: "相同输入必然产生相同输出，不依赖随机性"

  algorithm_components:
    priority_calculation:
      description: "计算任务优先级的核心函数"
      implementation: "calculate_priority(task) -> (urgency_level, complexity_score)"
      logic: "返回二元组，用于优先队列排序，值越大优先级越高"
      uniqueness_requirement: "所有任务的(urgency_level, complexity_score)组合必须唯一"

    queue_management:
      description: "三个核心数据结构管理任务状态"
      ready_queue:
        type: "优先队列（最大堆）"
        content: "已就绪的任务（无依赖或依赖已满足）"
        ordering: "按(-urgency_level, -complexity_score, task_id)排序"
      waiting_queue:
        type: "哈希表"
        content: "等待依赖满足的任务 {task_id: task}"
      completed_set:
        type: "集合"
        content: "已完成分配的任务ID集合"

    dependency_handling:
      description: "依赖关系的图结构管理和激活逻辑"
      dependency_graphs:
        forward: "dependencies - {task_id: [dep_task_ids]} 正向依赖图"
        backward: "dependents - {task_id: [dependent_task_ids]} 反向依赖图"
      activation_logic:
        trigger: "任务完成后，查找反向依赖图找出所有依赖当前任务的任务"
        check: "检查被依赖任务的所有依赖是否都已完成"
        action: "如果依赖全部满足，从waiting_queue移除并加入ready_queue"
      dependency_validation:
        completeness_check: "验证所有依赖任务都存在于任务集合中"
        circular_check: "使用DFS检测循环依赖"
        cleanup: "自动清理无效依赖引用"

    worker_selection_strategies:
      description: "根据任务特性选择最优人员的四种策略"
      basic_filtering:
        availability: "只选择availability_status='available'的人员"
        capability_match: "worker.capabilities必须完全覆盖task.required_capabilities（集合包含关系）"

      strategy_1_normal:
        condition: "urgency_level < 8 且 complexity_score < 7"
        name: "常规任务分配"
        logic: "_select_by_lowest_workload()"
        selection: "选择负载最低的候选人（current_workload_hours最小）"
        tie_breaking: "如果多人负载相同则返回None（确保唯一性）"

      strategy_2_urgent:
        condition: "urgency_level ≥ 8"
        name: "紧急任务分配"
        logic: "_select_by_lowest_workload_then_experience()"
        selection: "优先选择负载最低的候选人"
        tie_breaking: "负载相同时选择经验等级最高的（senior > intermediate > junior）"

      strategy_3_complex:
        condition: "complexity_score ≥ 7"
        name: "复杂任务分配"
        logic: "_select_by_senior_experience()"
        selection: "只在senior级别人员中选择"
        fallback: "如果无senior人员则返回None"
        tie_breaking: "多个senior时选择负载较低的"

      strategy_4_urgent_complex:
        condition: "urgency_level ≥ 8 且 complexity_score ≥ 7"
        name: "紧急复杂任务分配"
        logic: "_select_by_experience()"
        selection: "优先选择经验最高的候选人（senior优先）"
        tie_breaking: "同等经验时选择负载最低的"

  algorithm_workflow:
    step_1_initialization:
      action: "构建依赖关系图并初始化队列"
      operations:
        - "加载所有pending状态的任务"
        - "构建正向和反向依赖图（dependencies, dependents）"
        - "清理无效依赖引用"
        - "检查循环依赖（DFS）"
        - "将无依赖任务加入ready_queue"
        - "将有依赖任务加入waiting_queue"

    step_2_queue_processing:
      action: "循环处理就绪队列中的任务"
      loop_condition: "while ready_queue非空"
      operations:
        - "从ready_queue弹出最高优先级任务（heappop）"
        - "基本筛选：过滤available且技能匹配的候选人"
        - "策略选择：根据任务特性调用对应的人员选择策略"
        - "分配执行：更新task状态、assigned_worker_id、worker.current_workload_hours"
        - "依赖激活：将当前任务加入completed_set，激活其依赖任务"

    step_3_dependency_activation:
      action: "激活等待中的依赖任务"
      trigger: "任务从ready_queue处理完成后"
      operations:
        - "查找反向依赖图中依赖当前任务的所有任务"
        - "检查每个依赖任务的所有依赖是否都在completed_set中"
        - "如果依赖全部满足，从waiting_queue移除并加入ready_queue"

    step_4_validation:
      action: "验证分配结果的正确性和完整性"
      checks:
        - "所有pending任务都被分配（无剩余任务）"
        - "waiting_queue为空（无未激活的依赖任务）"
        - "每个任务都有唯一的分配结果"

  sample_generation_workflow:
    generator_class: "ScenarioGenerator"
    generation_strategy: "随机组合 + 唯一性筛选"

    step_1_random_scenario:
      description: "随机选择workers和tasks组成候选场景"
      worker_selection: "随机选择4-8个workers，确保至少70%为available状态"
      task_selection: "随机选择2-5个tasks，使用递归依赖闭包确保依赖完整性"
      dependency_closure_logic:
        - "随机选择种子任务"
        - "递归添加种子任务的所有依赖"
        - "重复直到达到目标任务数"
        - "如果添加闭包会超过目标数，则寻找更小的任务闭包"

    step_2_uniqueness_validation:
      description: "验证场景是否有唯一的最优分配方案"
      check_1_priority_uniqueness:
        checker: "_check_task_processing_order_uniqueness()"
        requirement: "所有任务的(urgency_level, complexity_score)组合必须唯一"
        reason: "确保任务处理顺序完全确定，无歧义"
      check_2_assignment_uniqueness:
        checker: "validate_scenario_uniqueness()"
        process: "运行完整的队列分配算法，验证是否成功分配所有任务"
        validation:
          - "每个任务都能找到满足条件的候选人"
          - "每个选择策略都能返回唯一最优人员（无并列）"
          - "所有任务最终都被分配"

    step_3_ground_truth_generation:
      description: "生成预期分配结果作为样本的ground truth"
      output_format:
        - "expected_assignments: 包含每个任务的预期分配对象和理由"
        - "expected_worker_updates: 包含每个worker的预期负载变化"
        - "assignment_sequence: 记录实际的任务处理顺序"
      quality_assurance:
        - "分配结果符合所有业务规则约束"
        - "工作负载更新计算准确（浮点数精度控制）"
        - "分配理由清晰且与策略一致"

    success_criteria:
      description: "合格样本必须满足的条件"
      criteria:
        - "优先级唯一性：(urgency_level, complexity_score)组合无重复"
        - "依赖完整性：所有依赖任务都存在于任务集合中"
        - "分配唯一性：每个任务都有唯一的最优人员"
        - "状态一致性：初始状态所有任务为pending，所有worker为available"
      rejection_cases:
        - "存在优先级冲突（多个任务优先级相同）→ 重新生成"
        - "存在循环依赖 → 重新生成"
        - "某个任务无满足条件的候选人 → 重新生成"
        - "人员选择出现并列（如多人负载相同）→ 重新生成"

  algorithm_key_insights:
    why_queue_based:
      reason: "依赖任务需要动态激活，简单的静态排序无法处理"
      benefit: "队列机制支持依赖任务完成后立即插入处理序列"

    why_priority_uniqueness:
      reason: "确保任务处理顺序完全确定，Agent可准确预测"
      benefit: "避免因处理顺序不同导致分配结果差异"
      implementation: "样本生成时强制验证，不合格样本直接丢弃"

    why_reject_ties:
      reason: "当多个候选人条件完全相同时，无法确定唯一最优"
      benefit: "确保ground truth的准确性和可复现性"
      example: "两个人负载都是5.0h，无法判断哪个更优 → 样本不合格"

    workload_precision:
      issue: "浮点数精度问题可能导致误判"
      solution: "±0.01小时容差，验证时使用rounded_comparison"
      implementation: "float_comparison_config.precision_tolerance: 0.01"

# 映射关系配置（简化为单一规则）
rule_execution_mapping:
  universal_assignment_rule:
    scenario_type: "principle_based_assignment"
    method_name: "_calculate_assignment_logic"
    expected_outcome_type: "principle_based_assignment"

checker_type_mapping:
  task_status_updated: "entity_attribute_equals"  # 验证任务状态更新为assigned
  task_assignment_verified: "entity_attribute_equals"  # 验证assigned_worker_id正确设置为预期worker_id
  workload_updated_correctly: "entity_attribute_equals"  # 验证分配人员的current_workload_hours正确增加(浮点数精度容差±0.01)
  
# 浮点数比较配置
float_comparison_config:
  precision_tolerance: 0.01  # 浮点数比较容差：±0.01小时
  workload_rounding: 2       # 工作负载小时数保留2位小数
  validation_method: "rounded_comparison"  # 使用四舍五入后比较，避免浮点精度问题

scenario_type_mapping:
  principle_based_assignment: "基于原则的智能分配"

# 运行时配置
runtime_config:
  system_time: "2025-07-22T14:00:00Z"
  timezone: "Asia/Shanghai" 
  current_date_description: "今天是2025年7月22日，当前时间是14:00"

# MCP服务配置
mcp_service_config:
  service_name: "intelligent_task_service"
  service_description: "智能任务分配服务，提供任务分配相关的CRUD操作"
  service_endpoint: "http://127.0.0.1:8402/mcp"

# 样本生成配置
sample_generation:
  sample_count: 15
  diversity_requirements:
    - 覆盖常规负载优先分配场景
    - 包含紧急任务优先经验的分配场景  
    - 包含复杂任务优先senior人员的分配场景
    - 测试依赖任务的优先分配逻辑
    - 验证各种任务特性组合的分配决策
  
# 数据约束 - 基于约束规则的场景要求（精简版）
business_constraints:
  verification_strategy:
    description: "基于结果的端到端验证策略"
    explanation: "实际系统经过评测迭代后，采用简化的验证策略，通过验证最终分配结果的正确性来隐式验证前置条件（能力匹配、可用性等）和优先级原则"
    core_checks:
      - "任务状态正确更新（pending → assigned）"
      - "分配对象符合优先级原则（通过验证assigned_worker_id是否为预期值）"
      - "工作负载精确更新（验证current_workload_hours增加量，浮点数容差±0.01小时）"
    implicit_verification:
      - "能力匹配：通过分配结果正确性隐式验证（若能力不匹配，预期分配对象就会错误）"
      - "可用性验证：通过分配对象正确性隐式验证（若状态非available，不会被选中）"
      - "优先级原则：通过预期worker_id验证（预期值已根据优先级原则计算）"
    rationale: "端到端验证比过程验证更robust，避免过度依赖中间状态和工具调用细节"
  worker_constraints:
    min_workers: 4
    max_workers: 8
    capability_distribution:
      技术支持: "至少2人"
      客户服务: "至少2人" 
      数据分析: "至少1人"
      项目管理: "至少1人"
    experience_distribution: "30% junior, 40% intermediate, 30% senior"
    availability_distribution: "70% available, 20% busy, 10% offline"
    capacity_utilization_scenarios:
      light_load: "0.0-0.3 (30%的available workers)"
      moderate_load: "0.3-0.7 (50%的available workers)"
      heavy_load: "0.7-0.95 (20%的available workers)"
  task_constraints:
    urgency_distribution: "20% high urgency (8-10), 50% medium (4-7), 30% low (1-3)"
    complexity_distribution: "25% complex (7-10), 50% medium (4-6), 25% simple (1-3)"
    capability_requirement_variety: "确保覆盖所有定义的能力标签"
    deadline_scenarios: "30%的任务有明确截止时间"
    task_type_distribution: "各任务类型均匀分布，确保覆盖所有枚举值"
    dependency_scenarios: "30%的任务有依赖关系，最多一层依赖深度"
    processing_order_uniqueness: "所有无依赖任务的(urgency_level, complexity_score)组合必须唯一，确保任务处理顺序完全确定"
  assignment_constraints:
    assignment_response_time: "30秒内完成分配决策"
    rationale_requirement: "所有分配必须包含清晰的reasoning"
    capacity_respect: "不向capacity_utilization≥1.0的worker分配任务"
  dependency_constraints:
    max_dependency_depth: 1  # 最多一层依赖
    dependency_ratio: 0.2    # 20%任务有依赖
    time_logical_consistency: "依赖任务created_time必须早于当前任务"
    relationship_validation: "所有dependencies中的task_id必须存在于数据中"